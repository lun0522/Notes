#Learn C++

1. use `static_cast<float>(3)` rather than `float(3)`
2. `enum class Color {...}`, then `Color color = Color::RED`; rather than `enum Color {...}`, then `Color color = COLOR_RED`. in this way enumerations are regarding as of "class" `Color`, so we cannot do `color = 2` i.e. regard it as an int value any more
3. if enums are used as array indices, we have to use `colors[static_cast<int>(Color::COLOR_RED)]` since they are not regarded as int values; in that case, we would rather use the traditional way: `namespace {enum Color {…}; }`, and then `colors[Color::COLOR_RED]`
4. `if (std::cin.fail()) { std::cin.clear(); std::cin.ignore(32767,'\n');`
5. `int *ptr = new int (5); delete ptr; ptr = nullptr;` operator `new` dynamically allocates a space, and returns the address of it. however `new` can fail and throw an exception; we can use `nt *ptr = new (std::nothrow) int (5);` instead, then a failed `new` will only causes `ptr` to be `nullptr` (**no** need to say `if (ptr) delete ptr;`)
6. for array: `int *array = new int[3] {1, 2, 3}; delete[] array; array = nullptr;`. note that the length needn't be known at compile time, but it cannot be omitted
7. use reference: `int &ref = other.something.value1; ref = 5;`
8. `std::array<int, 5> myarray = { 9, 7, 5, 3, 1 };`, the length cannot be omitted; `myarray.size()` to get length; `at()` will check whether the index is valid, `myarray.at(9) = 10;` will throw an exception
9. always pass `std::array` by reference or const reference, to prevent the compiler from making a copy of the array when the array was passed to the function;
10. `std::sort(myarray.begin(), myarray.end());`
11. no need to `delete` a `std::array`
12. `std::vector<int> array { 9, 7, 5, 3, 1 };` no need to include the length; `array = { 9, 8, 7 };` will make the length 3, rather than 5 with two 0 at the end; `array.resize(5);` will resize it, make the length 5, and append two 0 at the end; but resizing is expensive
13. `std::vector` has two attributes: `length` and `capacity` (`.length()` <= `.capacity()`). `capacity` keeps track of how much memory is allocated, while `length` keeps track of how much memory is actually used; `std::vector` will reallocate memory only when the current allocated memory is **not enough**, eg: `std::vector<int> array = { 9, 8, 7 };` (l = c = 3); `array.resize(5);` (reallocate, l = c = 5); `array = { 1, 2, 3 }` (does not reallocate, l = 3 while c = 5)
14. `std::vector` can be used as a stack: `push_back()` pushes an element on the stack, `back()` returns the value of the top element on the stack (without poping), and `pop_back()` pops an element off the stack; since reallocation is expensive, we'd better use `reserve()` to pre-reserve some room for future use, eg: `array.reserve(5)` will set the capacity to (at least) 5
15. no need to `delete` a `std::vector`
16. do not return a pointer or reference of a variable that is only valid inside the scope of function
17. `int& returnByReference()`, then `int &ref = returnByValue();` is invalid, but `const int &cref = returnByValue();` is valid since const references can bind to r-values (lifetime extended)
18. inline functions can be implemented in header files, since they are like `# define`
19. `int add(int x, int y);`, `const int add(int x, int y);`, `double add(double x, double y);` and `int add(int x, int y, int z)` can coexist, but `double add(int x, int y);` cannot, because return types are not considered for uniqueness; an ambiguous match will cause an exception, so we may use `add(static_cast<int>(a), static_cast<int>(b));` to force it to exactly match one of options
20. all default parameters of a function must be the rightmost parameters
21. default parameters can only be declared once, so we should use `void printValues(int x, int y=10);` in `.hpp` and `void printValues(int x, int y) {...}` in `.cpp`
22. `void printValues(int x);` and `void printValues(int x, int y=20);` will cause an ambiguous match if we only pass `x`, so it is not allowed
23. default parameters won’t work for functions called through function pointers
24. `typedef bool (*validateFcn)(int, int);` is the same to `using validateFcn = bool(*)(int, int);` or `std::function<bool(int, int)> validateFcn;`
25. `std::cerr << "function printString() received a null parameter";`
26. `#include <cstdlib>` then `exit(2);`
27. `#include <cassert>` then `assert(found && "Car could not be found in database");` to provide a description string; use `#define NDEBUG` to avoid that `assert()` appears in the production mode
28. `static_assert()` is operated in compile time rather than runtime, so it is used to check something that can be known at compile time, eg: `static_assert(sizeof(int) == 4, "int must be 4 bytes");`
29. use `int main(int argc, char *argv[])` (or `int main(int argc, char** argv)`) to take in parameters from command line, `argc` (argument count) tells the length of `*argv[]`, and each item of `*argv[]` is a string
30. class members are **private** by default; note that public methods can access to private members as well, even if that member is of a different instance
31. a constructor of a class should meet two requirements: should always have the same name as the class; have no return type (not even void). eg: for class `Fraction` which has two members: `m_numerator` and `m_denominator`, it can have constructors `Fraction() {...}` and `Fraction(int numerator, int denominator=1) {...}`; or more concisely, `Fraction(int numerator=0, int denominator=1) { m_numerator = numerator; m_denominator = denominator }`, which handles the default situation as well
32. in the previous example, if members `m_numerator` and `m_denominator` are of type `const`, we cannot assign values to them in the constructors. instead, we can use a initializer list: `Fraction(int numerator=0, int denominator=1): m_numerator(numerator), m_denominator(denominator) {...}`
33. we can also execute a method in the initializer list, eg: `Fraction(int denominator): Fraction(0, denominator) {...}`, in order to reduce the repeated code that has been written in `Fraction(int numerator=0, int denominator=1)`. this is a good way to realize a designated initializer. note that only a constructor can put a constructor in the intializer list
34. it is also viable to intialize members of a class when we declare them; we prefer this approach
35. the destructor can not take arguments, so it cannot be overloaded, it has no return types, and it should not be called explicitly (like `deallocate()`), eg: `~Fraction {...}`. note that when `exit()` is called, no destructors will be called
36. the implemention of methods needn't be written in the parenthesis of `class Fraction {...}`, but at anywhere with the class name as prefix, eg: `class Fraction {... int getNumerator(); ...};` then somewhere else `int Fraction::getNemerator() { return m_numerator; }`. so that the implemention can be put into `.cpp`
37. if an instance is declared to be `const`, we can only call its **const member functions**, which guarantee that nothing in the instance will be modified, eg: `int getNumerator const {...}`
38. static member variables are shared by all instances of the class; it is existing since this class is initialized (before any instantiation). so if we have `static int count;` inside of `Fraction`, we can access it by `Fraction::count` (remember to initialize it outside of `main()`)
39. static member functions are used to interact with static member variables, since non-static functions can only be used after instantiation. note that when we declare `static int GetNumerator();`, while in implemention we write `int GetNumerator() {...}`, where `static` is omitted
40. keyword `friend` makes it possible for a method to access private variables of instances of other class, eg: `class Temperature { private: int m_temp; public: friend void printWeather(const Temperature &temperature, const Humidity &humidity); }` then in the implemention of `printWeather` we can use `temperature.m_temp` (making the method a friend of class `Temperature`, thus the method can access all details of the class)
41. `friend` also makes it possible for a class to access private variables of instances of other class, eg: `class Temperature {... private: int m_temp; public: friend class Humidity; ...}` then in class `Humidity` we can use `temperature.m_temp`
42. to avoid to make the whole class a friend, we can use `friend void Humidity::displayTemperature(Temperature &temperature);` then implement this method in class `Humidity`
43. if a variable (may be instance) is used only once, we can make it anonymous (not giving it a name), eg: instead of `Cents cents1(6); Cents cents(8); Cents sum = add(cents1, cents2); cout << sum.getCents() << endl`, we do `cout << add(Cents(6), Cents(8)).getCents() << endl`
44. `friend Cents operator+(const Cents &c1, const Cents &c2)` then we can use `c1 + c2` for a custom-class object; it is also possible to add two objects of different type: `friend Cents operator+(int value, const Cents &c1)` then `6 + c1`; if we have a getter (`getCents()`) of that private variable (`m_cents`), we can use it and omit `friend` (in this case we should declare `Cents operator+(const Cents &c1, const Cents &c2);` outside of `class Cents {...}` in `.h`)
45. overload `<<` and `>>`: `std::ostream& operator<< (std::ostream &out, const Point &point) { out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ")"; return out; }` so that we can use `std::cout << point << endl;` to print out all variables at once; `std::istream& operator>> (std::istream &in, Point &point) { in >> point.m_x; in >> point.m_y; in >> point.m_z; return in; }` so that we can use `std::cin >> point;`; remember the return type should be a reference
46. it is also possible to overload operators as member functions, eg: `Cents operator+(int value);` in `class Cents {...}`, then `Cents Cents::operator+(int value) { return Cents(m_cents + value); }`; note that pointer `*this` is omitted; it serves as the left operand (first parameter); so if the first parameter isn't `*this` instance, we cannot use this method, like in the case of `<<`
47. overload unary operators: `Point operator- () const;` in `class Point {...}` then `Point Point::operator- () const { return Point(-m_x, -m_y, -m_z); }`; note that this function is delared to be a constant one, so it can take a const parameter
48. overload `++a` and `a++`: `Digit& operator++();` for `++a`, and `Digit operator++(int);` for `a++` in `class Digit {...}`, then `Digit& Digit::operator++() { if (m_digit == 9) m_digit = 0; else ++m_digit; return *this; }` and `Digit Digit::operator++(int) { Digit temp(m_digit); ++(*this); return temp; }`: note that `++a` is easy to implement, but `a++` is difficult: it has to return the state of the object **before** it is incremented, so we use `temp` to store that state and as return, and also increment `*this`; thus `a++` consumes more resources since we have to create a temp object; also note that we shouldn't return a reference because `temp` is a local variable
49. subscript operator `[]` can also be overloaded, and take variable of other type (like string) as parameter; `()` can be overloaded so that we have a more natural way to manipulate matrices: `double& Matrix::operator()(int row, int col) { return data[row][col]; }` and `const double& Matrix::operator()(int row, int col) const { return data[row][col]; }`, then use `matrix(1, 2)` instead of `matrix[1][2]`
50. typecasting can be overloaded for custom class, eg: `operator int() { return m_cents; }` in `class Cent {...}` then any instance of `Cent` can be cast into an int. note that this method has no return type
51. use `delete` to prevent some methods from executing, eg: `Fraction(const Fraction &copy) = delete;` then nobody can use `f1 = f2;`
52. to enable a custom class to initialize with a initializer list, eg: `IntArray array { 5, 4, 3, 2, 1 };`, we should write an initializer that takes `std::initializer_list` as a parameter, eg: `class IntArray { public: IntArray(const std::initializer_list<int> &list): IntArray(list.size()) { // deep copy here } }`; note that we should declare the type of the content of `std::initializer_list`; the `size()` of `std::initializer_list` can be used immediately
53. to subclass `class Base { ... }`, use `class Derived: public Base { ... }`. some member variables in `Base` might be private or const, which are hard to initialize in `Derived`, so the initializer of `Derived` should designates an initializer of `Base`. eg: suppose that `m_id` is a private member of `Base`, and `m_cost` is a private member of `Derived`, then `class Derived: public Base { Derived(double cost=0.0, int id=0) : Base(id), m_cost(cost) { ... } }` (just like `[super initWith...]`)
54. inheritance can also be protected or private (default is private). `class Derived: private Base { ... }` will make all variables that are declared to be public or protected in `Base` become private in `Derived`, while `class Derived: protected Base { ... }` will make all variables that are declared to be public in `Base` become protected in `Derived`. public inheritance is used most frequently
55. if we don't want the constructor method of a certain class to be used, we can make it protected, so that its subclass can still access this method, and people will only use the constructor of the subclass
56. when a method is overrode in a subclass, the access specifier can be changed, eg: `class Base { protected: void printValue() { std::cout << m_value; } }` and `class Derived: public Base { using Base::printValue; }`, then we can access `Derived:: printValue()` anywhere else; this can also be done to a member variable. a method can also be marked as deleted in the subclass, to make sure that it won't be called, eg: `void printValue() = delete;`
57. to call a method of parent class that will be overrode, remember to use the scope qualifier. eg: `class Derived: public Base { void identify() { Base::identify(); std::cout << "I am a Derived\n"; } }`. if that method is not a member of the parent class (just a friend), we should use `static_cast`, eg: `friend std::ostream& operator<< (std::ostream &out, const Derived &d) { out << static_cast<Base>(d); return out; }`
58. if `Cat`, `Dog` and some other animals are subclass of `Animal`, and all of them override a method called `getName()`, then if we use a pointer `Animal *` or a reference `Animal &` to point to their instances, and use it to call `getName()`, the method of `Animal` rather than its subclass will be called. to solve it, we can do `class Animal { virtual const char* getName() {...} }`, `class Cat: public Animal { virtual const char* getName() {...} }` and so on. keyword `virtual` will ask the program to search for the most derived method. note that don't call a virtual method in the (de)constructor method, because the subclass doesn't exist at that time
59. destructor method should be declared to be `virtual`, because its possible that we use `Animal *animal` to point to a `Cat`, if `delete animal;` isn't forced to find the destructor of `Cat`, it will only call that of `Animal`
60. it is still possible to call the method of parent class even if it is overrode, eg: `Cat cat; Animal &animal = cat; std::cout << animal.Animal::getName() << std::endl;`
61. use keyword `override` to find out those methods that are meant to override, but actually does not override anything, eg: `class Animal { virtual const char* getName() {...} }` while `class Cat: public Animal { virtual const char* getName() const override {...} }` will cause an error. this is recommended for every virtual method override
62. keyword `final` can make a method not overridable, eg: `class Animal { const char* getName() final {...} }`, then `class Cat: public Animal { const char* getName() {...} }` will cause an error. it can also make a class not inheritable, eg: `class Cat final : public Animal { ... }`, then any subclass of `Cat` will cause an error
63. in a subclass, if the return type of a method is a subclass of the return type of the method being overrode, it will also trigger overriding, eg: `class Base { virtual Base* getThis() { return this; } }`, then `class Derived: public Base { virtual Derived* getThis() { return this; } }` is an effective overriding
64. if a method is meant to be overrode by subclass, we can make it a pure virtual function, eg: `class Animal { virtual const char* speak() = 0; }` while `class Cow: public Animal { // no definition of method speak() }`, then `Animal animal;` or `Cow cow;` will cause an error, because the class contains a pure virtual function, thus it is considered an abstract base class, and cannot be instantiated. note that the pure virtual function can still have an implementation, which can be called by the subclass as a default implementation
65. we can create an interface class, where all methods are pure virtual, so that its subclass will have to implement all methods, and no private member variables will be exposed. remember to include a virtual destructor, see *point 59*
66. to convert a pointer of a base class to a pointer of a derived class, we can use `dynamic_cast`, which will return `null` if the conversion fails, so we should use: `Base *b = ...; Derived *d = dynamic_cast<Derived*>(b); if (d) {...}`. `static_cast` can also do the conversion, but it doesn't do the failure check, so it can be dangerous
67. `dynamic_cast` can also be used for reference, eg: `Base &b = ...; Derived &d = dynamic_cast<Derived&>(b);`. since there is no null reference, a failure in conversion will cause an exception
68. we can overload operator `<<`, but it cannot be virtualized because this overloading method isn't a member of the class. a detour is to overload `<<` in the base class, and let it call a member function `print()`, then in subclass override `print()`, so finally what will be called are `<<` in `Base` and `print()` in `Derived`
69. `template <class T> class Storage {...}`, `template <> class Storage<int> {...} // invoked only when T is int`, `template <class T> class Storage<T*> {...} // invoked only when T is pointer`, `template <> Storage<char*>::Storage(char* value) {...} // invoke this constructor only when T is char*`, then `Storage<int> myint(5); Storage<int*> myintptr(&x);`
70. `template <class T, int size> class StaticArray {...} // size should be assigned when initializing`, `template <typename T, int size> void print(StaticArray<T, size> &array) {...}`, `template <int size> void print(StaticArray<char, size> &array) {...} // invoked only when T is char`, then `StaticArray<char, 12> char12;`
71. 