#Learn C++

1. use `static_cast<float>(3)` rather than `float(3)`
2. `enum class Color {...}`, then `Color color = Color::RED`; rather than `enum Color {...}`, then `Color color = COLOR_RED`. in this way enumerations are regarding as of "class" `Color`, so we cannot do `color = 2` i.e. regard it as an int value any more
3. if enums are used as array indices, we have to use `colors[static_cast<int>(Color::COLOR_RED)]` since they are not regarded as int values; in that case, we would rather use the traditional way: `namespace {enum Color {…}; }`, and then `colors[Color::COLOR_RED]`
4. `if (std::cin.fail()) { std::cin.clear(); std::cin.ignore(32767,'\n');`
5. `int *ptr = new int (5); delete ptr; ptr = nullptr;` operator `new` dynamically allocates a space, and returns the address of it. however `new` can fail and throw an exception; we can use `nt *ptr = new (std::nothrow) int (5);` instead, then a failed `new` will only causes `ptr` to be `nullptr` (**no** need to say `if (ptr) delete ptr;`)
6. for array: `int *array = new int[3] {1, 2, 3}; delete[] array; array = nullptr;`. note that the length needn't be known at compile time, but it cannot be omitted
7. use reference: `int &ref = other.something.value1; ref = 5;`
8. `std::array<int, 5> myarray = { 9, 7, 5, 3, 1 };`, the length cannot be omitted; `myarray.size()` to get length; `at()` will check whether the index is valid, `myarray.at(9) = 10;` will throw an exception
9. always pass `std::array` by reference or const reference, to prevent the compiler from making a copy of the array when the array was passed to the function;
10. `std::sort(myarray.begin(), myarray.end());`
11. no need to `delete` a `std::array`
12. `std::vector<int> array { 9, 7, 5, 3, 1 };` no need to include the length; `array = { 9, 8, 7 };` will make the length 3, rather than 5 with two 0 at the end; `array.resize(5);` will resize it, make the length 5, and append two 0 at the end; but resizing is expensive
13. `std::vector` has two attributes: `length` and `capacity` (`.length()` <= `.capacity()`). `capacity` keeps track of how much memory is allocated, while `length` keeps track of how much memory is actually used; `std::vector` will reallocate memory only when the current allocated memory is **not enough**, eg: `std::vector<int> array = { 9, 8, 7 };` (l = c = 3); `array.resize(5);` (reallocate, l = c = 5); `array = { 1, 2, 3 }` (does not reallocate, l = 3 while c = 5)
14. `std::vector` can be used as a stack: `push_back()` pushes an element on the stack, `back()` returns the value of the top element on the stack (without poping), and `pop_back()` pops an element off the stack; since reallocation is expensive, we'd better use `reserve()` to pre-reserve some room for future use, eg: `array.reserve(5)` will set the capacity to (at least) 5
15. no need to `delete` a `std::vector`
16. do not return a pointer or reference of a variable that is only valid inside the scope of function
17. `int& returnByReference()`, then `int &ref = returnByValue();` is invalid, but `const int &cref = returnByValue();` is valid since const references can bind to r-values (lifetime extended)
18. inline functions can be implemented in header files, since they are like `# define`
19. `int add(int x, int y);`, `const int add(int x, int y);`, `double add(double x, double y);` and `int add(int x, int y, int z)` can coexist, but `double add(int x, int y);` cannot, because return types are not considered for uniqueness; an ambiguous match will cause an exception, so we may use `add(static_cast<int>(a), static_cast<int>(b));` to force it to exactly match one of options
20. all default parameters of a function must be the rightmost parameters
21. default parameters can only be declared once, so we should use `void printValues(int x, int y=10);` in `.hpp` and `void printValues(int x, int y) {...}` in `.cpp`
22. `void printValues(int x);` and `void printValues(int x, int y=20);` will cause an ambiguous match if we only pass `x`, so it is not allowed
23. default parameters won’t work for functions called through function pointers
24. `typedef bool (*validateFcn)(int, int);` is the same to `using validateFcn = bool(*)(int, int);` or `std::function<bool(int, int)> validateFcn;`
25. `std::cerr << "function printString() received a null parameter";`
26. `#include <cstdlib>` then `exit(2);`
27. `#include <cassert>` then `assert(found && "Car could not be found in database");` to provide a description string; use `#define NDEBUG` to avoid that `assert()` appears in the production mode
28. `static_assert()` is operated in compile time rather than runtime, so it is used to check something that can be known at compile time, eg: `static_assert(sizeof(int) == 4, "int must be 4 bytes");`
29. use `int main(int argc, char *argv[])` (or `int main(int argc, char** argv)`) to take in parameters from command line, `argc` (argument count) tells the length of `*argv[]`, and each item of `*argv[]` is a string
30. class members are **private** by default; note that public methods can access to private members as well, even if that member is of a different instance
31. a constructor of a class should meet two requirements: should always have the same name as the class; have no return type (not even void). eg: for class `Fraction` which has two members: `m_numerator` and `m_denominator`, it can have constructors `Fraction() {...}` and `Fraction(int numerator, int denominator=1) {...}`; or more concisely, `Fraction(int numerator=0, int denominator=1) { m_numerator = numerator; m_denominator = denominator }`, which handles the default situation as well
32. in the previous example, if members `m_numerator` and `m_denominator` are of type `const`, we cannot assign values to them in the constructors. instead, we can use a initializer list: `Fraction(int numerator=0, int denominator=1): m_numerator(numerator), m_denominator(denominator) {...}`
33. we can also execute a method in the initializer list, eg: `Fraction(int denominator): Fraction(0, denominator) {...}`, in order to reduce the repeated code that has been written in `Fraction(int numerator=0, int denominator=1)`. this is a good way to realize a designated initializer. note that only a constructor can put a constructor in the intializer list
34. it is also viable to intialize members of a class when we declare them; we prefer this approach
35. the destructor can not take arguments, so it cannot be overloaded, it has no return types, and it should not be called explicitly (like `deallocate()`), eg: `~Fraction {...}`. note that when `exit()` is called, no destructors will be called
36. the implemention of methods needn't be written in the parenthesis of `class Fraction {...}`, but at anywhere with the class name as prefix, eg: `class Fraction {... int getNumerator(); ...};` then somewhere else `int Fraction::getNemerator() { return m_numerator; }`. so that the implemention can be put into `.cpp`
37. if an instance is declared to be `const`, we can only call its **const member functions**, which guarantee that nothing in the instance will be modified, eg: `int getNumerator const {...}`
38. static member variables are shared by all instances of the class; it is existing since this class is initialized (before any instantiation). so if we have `static int count;` inside of `Fraction`, we can access it by `Fraction::count` (remember to initialize it outside of `main()`)
39. static member functions are used to interact with static member variables, since non-static functions can only be used after instantiation. note that when we declare `static int GetNumerator();`, while in implemention we write `int GetNumerator() {...}`, where `static` is omitted
40. keyword `friend` makes it possible for a method to access private variables of instances of other class, eg: `class Temperature { private: int m_temp; public: friend void printWeather(const Temperature &temperature, const Humidity &humidity); }` then in the implemention of `printWeather` we can use `temperature.m_temp` (making the method a friend of class `Temperature`, thus the method can access all details of the class)
41. `friend` also makes it possible for a class to access private variables of instances of other class, eg: `class Temperature {... private: int m_temp; public: friend class Humidity; ...}` then in class `Humidity` we can use `temperature.m_temp`
42. to avoid to make the whole class a friend, we can use `friend void Humidity::displayTemperature(Temperature &temperature);` then implement this method in class `Humidity`
43. if a variable (may be instance) is used only once, we can make it anonymous (not giving it a name), eg: instead of `Cents cents1(6); Cents cents(8); Cents sum = add(cents1, cents2); cout << sum.getCents() << endl`, we do `cout << add(Cents(6), Cents(8)).getCents() << endl`
44. `friend Cents operator+(const Cents &c1, const Cents &c2)` then we can use `c1 + c2` for a custom-class object; it is also possible to add two objects of different type: `friend Cents operator+(int value, const Cents &c1)` then `6 + c1`; if we have a getter (`getCents()`) of that private variable (`m_cents`), we can use it and omit `friend` (in this case we should declare `Cents operator+(const Cents &c1, const Cents &c2);` outside of `class Cents {...}` in `.h`)
45. overload `<<` and `>>`: `std::ostream& operator<< (std::ostream &out, const Point &point) { out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ")"; return out; }` so that we can use `std::cout << point << endl;` to print out all variables at once; `std::istream& operator>> (std::istream &in, Point &point) { in >> point.m_x; in >> point.m_y; in >> point.m_z; return in; }` so that we can use `std::cin >> point;`; remember the return type should be a reference
46. it is also possible to overload operators as member functions, eg: `Cents operator+(int value);` in `class Cents {...}`, then `Cents Cents::operator+(int value) { return Cents(m_cents + value); }`; note that pointer `*this` is omitted; it serves as the left operand (first parameter); so if the first parameter isn't `*this` instance, we cannot use this method, like in the case of `<<`
47. overload unary operators: `Point operator- () const;` in `class Point {...}` then `Point Point::operator- () const { return Point(-m_x, -m_y, -m_z); }`; note that this function is delared to be a constant one, so it can take a const parameter
48. overload `++a` and `a++`: `Digit& operator++();` for `++a`, and `Digit operator++(int);` for `a++` in `class Digit {...}`, then `Digit& Digit::operator++() { if (m_digit == 9) m_digit = 0; else ++m_digit; return *this; }` and `Digit Digit::operator++(int) { Digit temp(m_digit); ++(*this); return temp; }`: note that `++a` is easy to implement, but `a++` is difficult: it has to return the state of the object **before** it is incremented, so we use `temp` to store that state and as return, and also increment `*this`; thus `a++` consumes more resources since we have to create a temp object; also note that we shouldn't return a reference because `temp` is a local variable
49. subscript operator `[]` can also be overloaded, and take variable of other type (like string) as parameter; `()` can be overloaded so that we have a more natural way to manipulate matrices: `double& Matrix::operator()(int row, int col) { return data[row][col]; }` and `const double& Matrix::operator()(int row, int col) const { return data[row][col]; }`, then use `matrix(1, 2)` instead of `matrix[1][2]`
50. typecasting can be overloaded for custom class, eg: `operator int() { return m_cents; }` in `class Cent {...}` then any instance of `Cent` can be cast into an int. note that this method has no return type
51. use `delete` to prevent some methods from executing, eg: `Fraction(const Fraction &copy) = delete;` then nobody can use `f1 = f2;`
52. 